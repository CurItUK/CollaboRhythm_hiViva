<?xml version="1.0" encoding="utf-8"?>
<!--~
  ~ Copyright 2011 John Moore, Scott Gilroy
  ~
  ~ This file is part of CollaboRhythm.
  ~
  ~ CollaboRhythm is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
  ~ License as published by the Free Software Foundation, either version 2 of the License, or (at your option) any later
  ~ version.
  ~
  ~ CollaboRhythm is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
  ~ warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
  ~ details.
  ~
  ~ You should have received a copy of the GNU General Public License along with CollaboRhythm.  If not, see
  ~ <http://www.gnu.org/licenses/>.
  -->
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009"
		 xmlns:s="library://ns.adobe.com/flex/spark"
		 xmlns:mx="library://ns.adobe.com/flex/mx"
		 xmlns:dataShapes="qs.charts.dataShapes.*"
		 xmlns:simulation="collaboRhythm.plugins.bloodPressure.view.simulation.*"
		 xmlns:controls="com.dougmccune.controls.*" xmlns:view="collaboRhythm.plugins.bloodPressure.view.*"
		 xmlns:images="assets.images.*"
		 xmlns:buttons="collaboRhythm.plugins.bloodPressure.view.simulation.buttons.*"
		 width="100%" height="100%"
		 creationComplete="creationCompleteHandler(event)"
		 clipAndEnableScrolling="true"
		 implements="mx.managers.IFocusManagerComponent"
		 initialize="initializeHandler(event)"
		>
	<fx:Style source="/collaboRhythm/plugins/bloodPressure/view/ChartStyles.css"/>
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->

		<controls:SynchronizedAxisCache id="synchronizedAxisCache"/>

		<mx:PlotSeries id="systolicSeries" name="systolic" xField="dateMeasuredStart" yField="resultAsNumber"
					   dataProvider="{model.isInitialized ? model.systolicData : null}"
					   updateComplete="series_updateCompleteHandler(event)"
					   filterDataValues="none" displayName="Blood Pressure Systolic"
				>
			<mx:itemRenderer>
				<fx:Component>
					<view:BloodPressurePlotItemRenderer deltaY="-8"/>
				</fx:Component>
			</mx:itemRenderer>
			<mx:stroke>
				<s:SolidColorStroke weight="2" color="0x000000"/>
			</mx:stroke>

		</mx:PlotSeries>
		<mx:PlotSeries id="diastolicSeries" name="diastolic" xField="dateMeasuredStart" yField="resultAsNumber"
					   dataProvider="{model.isInitialized ? model.diastolicData : null}"
					   updateComplete="series_updateCompleteHandler(event)"
					   filterDataValues="none" displayName="Blood Pressure Diastolic"
				>
			<mx:itemRenderer>
				<fx:Component>
					<view:BloodPressurePlotItemRenderer/>
				</fx:Component>
			</mx:itemRenderer>
			<mx:stroke>
				<s:SolidColorStroke weight="2" color="0x808080"/>
			</mx:stroke>

		</mx:PlotSeries>

		<mx:LineSeries id="systolicRangeSeries" name="systolic" xField="dateMeasuredStart" yField="resultAsNumber"
					   dataProvider="{model.isInitialized ? model.systolicData : null}"
					   form="segment"
					   filterDataValues="none"
				>
			<mx:lineStroke>
				<s:SolidColorStroke
						color="0x4252A4"
						weight="1"
						/>
			</mx:lineStroke>
		</mx:LineSeries>
		<mx:LineSeries id="diastolicRangeSeries" name="diastolic" xField="dateMeasuredStart" yField="resultAsNumber"
					   dataProvider="{model.isInitialized ? model.diastolicData : null}"
					   form="segment"
					   filterDataValues="none"
				>
			<mx:lineStroke>
				<s:SolidColorStroke
						color="0x4252A4"
						weight="1"
						alpha="0.3"
						/>
			</mx:lineStroke>
		</mx:LineSeries>
		<!--
		<mx:AreaSeries id="heartRateSeries" name="heart rate" xField="date" yField="heartRate"
					   fill="{new SolidColor(0x4252A4, .75)}" 
					   radius="2.5" form="segment"
					   itemRenderer="skins.LineSeriesCustomRenderer" 
					   updateComplete="heartRateChart.seriesComplete();"
					   filterDataValues="none"
					   />
-->

		<mx:DateFormatter id="fullDateFormat" formatString="YYYY-MM-DD"/>

		<dataShapes:DataDrawingCanvas id="bloodPressureMainCanvas" includeInRanges="true">
			<s:Label id="systolicZoneLabel" text="Systolic Normal (90 - 120)" styleName="ZoneLabel" visible="false"
					 color="{GOAL_ZONE_COLOR}"/>
			<!--
			<s:Label id="diastolicZoneLabel" text="Diastolic Normal (60 - 80)" styleName="ZoneLabel" color="{GOAL_ZONE_COLOR}"/>
			-->
		</dataShapes:DataDrawingCanvas>

		<dataShapes:DataDrawingCanvas id="bloodPressureRangeCanvas" includeInRanges="true" height="100%" width="100%">
		</dataShapes:DataDrawingCanvas>

	</fx:Declarations>

	<fx:Script><![CDATA[
		import collaboRhythm.shared.apps.bloodPressure.model.BloodPressureModel;
		import collaboRhythm.shared.apps.bloodPressure.model.MedicationComponentAdherenceModel;
		import collaboRhythm.shared.apps.bloodPressure.model.SimulationModel;
		import collaboRhythm.shared.model.StringUtils;
		import collaboRhythm.shared.model.healthRecord.derived.MedicationConcentrationSample;
		import collaboRhythm.shared.model.healthRecord.document.AdherenceItem;
		import collaboRhythm.shared.model.healthRecord.document.MedicationAdministration;
		import collaboRhythm.shared.model.healthRecord.document.MedicationFill;
		import collaboRhythm.shared.model.healthRecord.document.MedicationFillsModel;
		import collaboRhythm.shared.model.healthRecord.document.MedicationScheduleItem;
		import collaboRhythm.shared.model.healthRecord.document.VitalSign;
		import collaboRhythm.shared.model.healthRecord.util.MedicationName;
		import collaboRhythm.shared.model.healthRecord.util.MedicationNameUtil;
		import collaboRhythm.shared.model.services.IMedicationColorSource;
		import collaboRhythm.shared.model.services.WorkstationKernel;
		import collaboRhythm.shared.model.settings.Settings;
		import collaboRhythm.view.scroll.TouchScrollerEvent;

		import com.dougmccune.controls.ScrubChart;
		import com.dougmccune.controls.TouchScrollingScrubChart;
		import com.dougmccune.events.FocusTimeEvent;
		import com.theory9.data.types.OrderedMap;

		import mx.charts.ChartItem;
		import mx.charts.DateTimeAxis;
		import mx.charts.LinearAxis;
		import mx.charts.chartClasses.CartesianChart;
		import mx.charts.chartClasses.CartesianDataCanvas;
		import mx.charts.chartClasses.ChartBase;
		import mx.charts.chartClasses.Series;
		import mx.charts.series.AreaSeries;
		import mx.charts.series.PlotSeries;
		import mx.collections.ArrayCollection;
		import mx.controls.Alert;
		import mx.effects.Sequence;
		import mx.events.EffectEvent;
		import mx.events.FlexEvent;
		import mx.events.PropertyChangeEvent;
		import mx.events.ResizeEvent;
		import mx.events.ScrollEvent;
		import mx.graphics.SolidColor;
		import mx.logging.ILogger;
		import mx.logging.Log;
		import mx.rpc.events.FaultEvent;

		import qs.charts.dataShapes.DataDrawingCanvas;
		import qs.charts.dataShapes.Edge;

		import skins.LineSeriesCustomRenderer;

		import spark.components.Image;

		import spark.components.Label;
		import spark.components.supportClasses.GroupBase;
		import spark.effects.Animate;
		import spark.effects.animation.MotionPath;
		import spark.effects.animation.SimpleMotionPath;
		import spark.effects.easing.Linear;
		import spark.layouts.VerticalAlign;

		private static const SIMULATION_VIEW_WIDTH:int = 680;
		private static const BLOOD_PRESSURE_VERTICAL_AXIS_MAXIMUM:int = 180;
		private static const BLOOD_PRESSURE_VERTICAL_AXIS_MINIMUM:int = 40;

		private var _textFormat:TextFormat = new TextFormat("Myriad Pro, Verdana, Helvetica, Arial", 16, 0, true);

		private var _model:BloodPressureModel;
		private var _traceEventHandlers:Boolean = true;
		private var _showFocusTimeMarker:Boolean = true;
		private var _scrollEnabled:Boolean = false;
		protected var logger:ILogger;
		private var _rangeChartVisible:Boolean = false;
		private var _adherenceCharts:OrderedMap = new OrderedMap();
		private var _adherenceChartsCreated:Boolean;
		private var _medicationColorSource:IMedicationColorSource;
		private var _modality:String;

		private var simulationOnlyViewMode:Boolean = false;
		private var _chartsOnlyViewMode:Boolean = false;
		private var _initialDurationTime:Number = ScrubChart.DAYS_TO_MILLISECONDS * 7;
		private var _useHorizontalTouchScrolling:Boolean = true;

		private const GOAL_ZONE_COLOR:uint = 0x8DCB86;
		private var seriesSets:Vector.<ScrubChartSeriesSet> = new Vector.<ScrubChartSeriesSet>();
		private var _seriesWithPendingUpdateComplete:ArrayCollection = new ArrayCollection();
		private var _chartsWithPendingCreationComplete:ArrayCollection = new ArrayCollection();
		private var _pendingSynchronizeDateLimits:Boolean;

		private function initializeHandler(event:Event):void
		{
			logger = Log.getLogger(getQualifiedClassName(this).replace("::", "."));
			_medicationColorSource = WorkstationKernel.instance.resolve(IMedicationColorSource) as IMedicationColorSource;
		}

		[Bindable]
		public function get scrollEnabled():Boolean
		{
			return _scrollEnabled;
		}

		public function set scrollEnabled(value:Boolean):void
		{
			_scrollEnabled = value;
		}

		[Bindable]
		public function get showFocusTimeMarker():Boolean
		{
			return _showFocusTimeMarker;
		}

		public function set showFocusTimeMarker(value:Boolean):void
		{
			_showFocusTimeMarker = value;
		}

		public function get rangeChartVisible():Boolean
		{
			return _rangeChartVisible;
		}

		public function set rangeChartVisible(value:Boolean):void
		{
			_rangeChartVisible = value;
			updateRangeChartVisibleStyles();
		}

		[Bindable]
		public function get model():BloodPressureModel
		{
			return _model;
		}

		public function set model(value:BloodPressureModel):void
		{
			_model = value;

			refresh();

			if (simulationView)
				simulationView.initializeModel(model.focusSimulation, model);

			_model.addEventListener(PropertyChangeEvent.PROPERTY_CHANGE, model_propertyChangeHandler, false, 0, true);
			_model.addEventListener(FlexEvent.UPDATE_COMPLETE, model_updateCompleteHandler, false, 0, true);
			_model.addEventListener(Event.CHANGE, model_changeHandler, false, 0, true);
		}

		private function model_changeHandler(event:Event):void
		{
			queueSynchronizeDateLimits();
		}

		private function model_updateCompleteHandler(event:FlexEvent):void
		{
			queueSynchronizeDateLimits();
		}

		private function queueSynchronizeDateLimits():void
		{
			_pendingSynchronizeDateLimits = true;
			invalidateProperties();
		}

		private function model_propertyChangeHandler(event:PropertyChangeEvent):void
		{
			//trace("model_propertyChangeHandler", event.property);
			if (event.property == "showAdherence" || event.property == "isInitialized")
			{
				_seriesWithPendingUpdateComplete.removeAll();

				if (model.isInitialized)
					initializeSeriesSets();

				if (model.isInitialized && model.showAdherence)
					createAdherenceCharts();

				updateSeries();
				setSingleChartMode(null, false);
			}
		}

		private function createAdherenceCharts():void
		{
			if (!_adherenceChartsCreated)
			{
				_adherenceChartsCreated = true;
				for each (var medicationCode:String in model.medicationConcentrationCurvesByCode.keys)
				{
					var medicationFill:MedicationFill = getMedicationFill(medicationCode);
					var medicationAdministrationsCollection:ArrayCollection = model.record.medicationAdministrationsModel.medicationAdministrationsCollectionsByCode.getItem(medicationCode);
					if (medicationAdministrationsCollection && medicationAdministrationsCollection[0])
					{
						var medicationAdministration:MedicationAdministration = medicationAdministrationsCollection[0];
						var medicationModel:MedicationComponentAdherenceModel = model.focusSimulation.getMedication(medicationCode);
						if (medicationModel == null)
							throw new Error("Medication " + medicationCode + " is in model.medicationConcentrationCurvesByCode but not in model.simulation.medicationsByCode");

						var medicationScheduleItem:MedicationScheduleItem = medicationModel.medicationScheduleItem;

						var chart:TouchScrollingScrubChart = new TouchScrollingScrubChart();
						chart.id = "adherence" + medicationCode;
						chart.setStyle("medicationCode", medicationCode);
						if (medicationFill)
							chart.setStyle("ndcCode", medicationFill.ndc.text);
						chart.setStyle("skinClass", ScrubChartMedicationSkin);
						chart.percentWidth = 100;
						chart.percentHeight = 100;
						chart.setStyle("sliderVisible", false);
						var nameString:String;
						if (medicationFill)
							nameString = medicationFill.name.text;
						else
							nameString = medicationAdministration.name.text;
						var medicationName:MedicationName = MedicationNameUtil.parseName(nameString);
						chart.mainChartTitle = medicationName.medicationName;

						chart.seriesName = "concentration";
						chart.data = model.medicationConcentrationCurvesByCode.getItem(medicationCode);
						chart.today = model.currentDateSource.now();
						chart.showFps = model.showFps;
						chart.initialDurationTime = initialDurationTime;
						chart.showFocusTimeMarker = false;
						chart.scrollEnabled = scrollEnabled;
						chart.synchronizedAxisCache = synchronizedAxisCache;
						chart.useHorizontalTouchScrolling = useHorizontalTouchScrolling;

						chart.addEventListener(ScrollEvent.SCROLL, chart_scrollHandler, false, 0, true);
						chart.addEventListener(TouchScrollerEvent.SCROLL_START, chart_scrollStartHandler, false, 0,
											   true);
						chart.addEventListener(TouchScrollerEvent.SCROLL_STOP, chart_scrollStopHandler, false, 0, true);
						chart.addEventListener(FocusTimeEvent.FOCUS_TIME_CHANGE, chart_focusTimeChangeHandler, false, 0,
											   true);
						chart.addEventListener(FlexEvent.CREATION_COMPLETE, adherenceChart_creationCompleteHandler);

						_chartsWithPendingCreationComplete.addItem(chart);
						_adherenceCharts.addKeyValue(medicationCode, chart);

						chart.percentWidth = 100;
						chart.percentHeight = 100;

						var medicationView:MedicationScheduleItemChartView = new MedicationScheduleItemChartView();
						medicationView.medicationScheduleItem = medicationScheduleItem;
						medicationView.verticalAlign = VerticalAlign.MIDDLE;
						medicationView.percentHeight = 100;

						var adherenceGroup:HGroup = new HGroup();
						adherenceGroup.gap = 0;
						adherenceGroup.addElement(medicationView);
						adherenceGroup.addElement(chart);
						adherenceGroup.percentWidth = 100;
						adherenceGroup.percentHeight = 100;

						// add the new chart before the blood pressure chart
						chartsGroup.addElementAt(adherenceGroup, chartsGroup.numElements - 1);
					}
				}
			}
		}

		protected function adherenceChart_creationCompleteHandler(event:FlexEvent):void
		{
			if (_traceEventHandlers)
				trace("adherenceChart_creationCompleteHandler");
			var chart:ScrubChart = ScrubChart(event.target);
//			chart.removeDefaultSeries();

			var medicationCode:String = chart.getStyle("medicationCode");
			var medicationModel:MedicationComponentAdherenceModel = model.focusSimulation.getMedication(medicationCode);

			var verticalAxis:LinearAxis = chart.mainChart.verticalAxis as LinearAxis;
			verticalAxis.minimum = 0;
			verticalAxis.maximum = medicationModel.concentrationAxisMaximum;

			if (chart.rangeChart)
			{
				verticalAxis = chart.rangeChart.verticalAxis as LinearAxis;
				verticalAxis.minimum = 0;
				verticalAxis.maximum = 0.4;
			}

			var ndcCode:String = chart.getStyle("ndcCode");
			updateMedicationChartSeries(chart, medicationCode, ndcCode);

			var mainCanvas:DataDrawingCanvas = new DataDrawingCanvas();
			mainCanvas.includeInRanges = true;
			mainCanvas.percentWidth = 100;
			mainCanvas.percentHeight = 100;
//			var mainCanvas:DataDrawingCanvas = chart.mainChart.backgroundElements[0] as DataDrawingCanvas;
			updateAdherenceChartSeriesCompleteHandler(chart, mainCanvas, null,
													  null, medicationCode, ndcCode);
//			var mainCartesianDataCanvas:CartesianDataCanvas = chart.mainChart.backgroundElements[1] as CartesianDataCanvas;
//			drawAdherenceData2(chart.mainChart, mainCartesianDataCanvas, null, medicationCode, ndcCode);

			var index:int = _chartsWithPendingCreationComplete.getItemIndex(chart);
			if (index != -1)
				_chartsWithPendingCreationComplete.removeItemAt(index);
		}

		private function updateMedicationChartSeries(chart:ScrubChart, medicationCode:String, ndcCode:String):void
		{
			chart.removeDefaultSeries();
			addConcentrationSeries(chart, medicationCode, ndcCode);
			addAdherenceSeries(chart, medicationCode);
		}

		private function addConcentrationSeries(chart:ScrubChart, medicationCode:String, ndcCode:String):void
		{
			var concentrationSeries:AreaSeries = new AreaSeries();
			concentrationSeries.name = "concentration";
			concentrationSeries.xField = "date";
			concentrationSeries.yField = "concentration";
//			concentrationSeries.dataProvider = model.medicationConcentrationCurvesByCode.getItem(medicationCode);
			concentrationSeries.dataProvider = chart.mainData;
			concentrationSeries.setStyle("radius", 2.5);
			concentrationSeries.setStyle("form", "curve");
			concentrationSeries.setStyle("itemRenderer", new ClassFactory(LineSeriesCustomRenderer));
			_seriesWithPendingUpdateComplete.addItem(concentrationSeries);
			concentrationSeries.addEventListener(FlexEvent.UPDATE_COMPLETE, series_updateCompleteHandler);
			concentrationSeries.filterDataValues = "none";
			var color:uint = getMedicationColor(ndcCode);
			concentrationSeries.setStyle("areaStroke", new SolidColorStroke(0x000000, 1));
			concentrationSeries.setStyle("areaFill", new SolidColor(color, 1));

			chart.mainChart.series.push(concentrationSeries);
			chart.addDataSet(model.medicationConcentrationCurvesByCode.getItem(medicationCode), "date");
		}

		private function series_updateCompleteHandler(event:FlexEvent):void
		{
			var series:Series = event.target as Series;
			series.removeEventListener(FlexEvent.UPDATE_COMPLETE, series_updateCompleteHandler, false);
			checkAllSeriesComplete(series);
		}

		private function addAdherenceSeries(chart:ScrubChart, medicationCode:String):void
		{
			var adherenceSeries:PlotSeries = new PlotSeries();
			adherenceSeries.name = "adherence";
			adherenceSeries.xField = "dateReported";
//			TODO: position the adherence series without the hack of using adherencePosition
			adherenceSeries.yField = "adherencePosition";
			adherenceSeries.dataProvider = model.adherenceItemsCollectionsByCode.getItem(medicationCode);
			adherenceSeries.setStyle("itemRenderer", new ClassFactory(AdherencePlotItemRenderer));
//			adherenceSeries.filterFunction = adherenceSeriesFilter;
			_seriesWithPendingUpdateComplete.addItem(adherenceSeries);
			adherenceSeries.addEventListener(FlexEvent.UPDATE_COMPLETE, series_updateCompleteHandler);

			chart.mainChart.series.push(adherenceSeries);
			chart.addDataSet(model.adherenceItemsCollectionsByCode.getItem(medicationCode), "dateReported");
		}

		private function getMedicationFill(medicationCode:String):MedicationFill
		{
			var medicationFill:MedicationFill;
			var adherenceItemsCollection:ArrayCollection = model.adherenceItemsCollectionsByCode.getItem(medicationCode);
			medicationFill = null;
			if (adherenceItemsCollection)
			{
				for each (var adherenceItem:AdherenceItem in adherenceItemsCollection)
				{
					var medicationScheduleItem:MedicationScheduleItem = adherenceItem.scheduleItem as MedicationScheduleItem;
					if (medicationScheduleItem)
					{
						if (medicationScheduleItem.scheduledMedicationOrder)
						{
							medicationFill = medicationScheduleItem.scheduledMedicationOrder.medicationFill;
							break;
						}
					}
				}
			}
			return medicationFill;
		}

		private function addSeries(chart:CartesianChart, series:Series):void
		{
			var data:ArrayCollection = series.dataProvider as ArrayCollection;
			if (data && data.length > 0)
				chart.series.push(series);
		}

		public function refresh():void
		{
			if (chartsGroup)
				setSingleChartMode(null, false);

			if (simulationView)
			{
				simulationView.initializeModel(model.focusSimulation, model);
				simulationView.refresh();
			}
		}

		private function adherenceSeriesFilter(cache:Array):Array
		{
			var filteredCache:Array = new Array();

			for each (var element:ChartItem in cache)
			{
				if (element.item.hasOwnProperty("adherence"))
					filteredCache.push(element);
			}

			return filteredCache;
		}

		protected function creationCompleteHandler(event:FlexEvent):void
		{
			updateSeries();
			refresh();
			simulationOnlyViewMode = false;
			updateComponentsForSimulationOnlyViewMode();
			updateRangeChartVisibleStyles();
		}

		public function drawBloodPressureData(canvas:DataDrawingCanvas):void
		{
			if (_traceEventHandlers)
				trace(this + ".drawBloodPressureData");

			canvas.clear();

			canvas.lineStyle(1, GOAL_ZONE_COLOR);

			// systolic normal
			canvas.beginFill(GOAL_ZONE_COLOR, 0.2);
			canvas.drawRect([Edge.LEFT, -1], SimulationModel.SYSTOLIC_GOAL, [Edge.RIGHT, 1], 90);
			canvas.endFill();

			//				// diastolic normal
			//				canvas.beginFill(GOAL_ZONE_COLOR, 0.2);
			//				canvas.drawRect(Edge.LEFT, 80, Edge.RIGHT, 60);
			//				canvas.endFill();

			if (canvas == bloodPressureMainCanvas)
			{
				canvas.updateDataChild(systolicZoneLabel, {left: Edge.LEFT, top: SimulationModel.SYSTOLIC_GOAL});
				//				canvas.updateDataChild(diastolicZoneLabel, {left: Edge.LEFT, bottom: 60});
			}
		}

		public function drawAdherenceData(canvas:DataDrawingCanvas, zoneLabel:Label, medicationCode:String,
										  ndcCode:String):void
		{
			if (_traceEventHandlers)
				trace(this + ".drawAdherenceData");

			canvas.clear();

			var medicationModel:MedicationComponentAdherenceModel = model.focusSimulation.getMedication(medicationCode);
			var color:uint = getMedicationColor(ndcCode);
			canvas.lineStyle(1, color);

			canvas.beginFill(color, 0.25);
			canvas.drawRect([Edge.LEFT, -1], medicationModel.goalConcentrationMinimum, [Edge.RIGHT, 1],
							medicationModel.goalConcentrationMaximum);
			canvas.endFill();

			if (zoneLabel)
			{
				zoneLabel.setStyle("color", color);
				canvas.updateDataChild(zoneLabel, {left: Edge.LEFT, top: medicationModel.goalConcentrationMaximum});
			}
		}

		/*
		 public function drawAdherenceData2(chart:CartesianChart, canvas:CartesianDataCanvas, zoneLabel:Label, medicationCode:String,
		 ndcCode:String):void
		 {
		 if (_traceEventHandlers)
		 trace(this + ".drawAdherenceData2");

		 canvas.clear();

		 var medicationModel:MedicationComponentAdherenceModel = model.focusSimulation.getMedication(medicationCode);
		 var color:uint = getMedicationColor(ndcCode);
		 canvas.lineStyle(3, color);

		 canvas.beginFill(color, 0.25);
		 canvas.drawRect((chart.horizontalAxis as DateTimeAxis).minimum, medicationModel.goalConcentrationMinimum, model.currentDateSource.now(),
		 medicationModel.goalConcentrationMaximum);
		 canvas.endFill();

		 if (zoneLabel)
		 {
		 zoneLabel.setStyle("color", color);
		 canvas.updateDataChild(zoneLabel, {left: Edge.LEFT, top: medicationModel.goalConcentrationMaximum});
		 }
		 }
		 */

		//			private function offsetDataToToday(data:ArrayCollection, newDate:Date):void
		//			{
		//				var lastDate:Date = bloodPressureChart.dateParse(data[data.length - 1].date);
		//				var delta:Number = newDate.time - lastDate.time;
		//
		//				for each (var dataItem:Object in data)
		//				{
		//					var dataItemDate:Date = bloodPressureChart.dateParse(dataItem.date);
		//					dataItemDate.time += delta;
		//					var formattedDate:String = fullDateFormat.format(dataItemDate);
		//
		//					dataItem.date = formattedDate;
		//				}
		//			}

		/**
		 * If an error occurs loading the XML chart info
		 */
		private function faultResult(event:FaultEvent):void
		{
			Alert.show("Error retrieving XML data", "Error");
		}

		protected function bloodPressureChart_creationCompleteHandler(event:FlexEvent):void
		{
			if (_traceEventHandlers)
				trace(this + ".bloodPressureChart_creationCompleteHandler");

			var chart:ScrubChart = ScrubChart(event.target);
			chart.removeDefaultSeries();

			var verticalAxis:LinearAxis = chart.mainChart.verticalAxis as LinearAxis;
			verticalAxis.minimum = BLOOD_PRESSURE_VERTICAL_AXIS_MINIMUM;
			verticalAxis.maximum = BLOOD_PRESSURE_VERTICAL_AXIS_MAXIMUM;

			if (chart.rangeChart)
			{
				verticalAxis = chart.rangeChart.verticalAxis as LinearAxis;
				verticalAxis.minimum = BLOOD_PRESSURE_VERTICAL_AXIS_MINIMUM;
				verticalAxis.maximum = BLOOD_PRESSURE_VERTICAL_AXIS_MAXIMUM;
			}
			//				synchronizeDateLimits();

			updateBloodPressureChartBackgroundElements(chart);

			chart.mainChart.addEventListener(Event.RESIZE, bloodPressureChart_mainChart_resizeHandler, false, 0,
											 true);

			if (modality == Settings.MODALITY_TABLET)
			{
				if (chart.rangeOneMonthButton)
					chart.rangeOneMonthButton.includeInLayout = chart.rangeOneMonthButton.visible = false;
				if (chart.rangeOneYearButton)
					chart.rangeOneYearButton.includeInLayout = chart.rangeOneYearButton.visible = false;
				if (chart.rangeMaxButton)
					chart.rangeMaxButton.includeInLayout = chart.rangeMaxButton.visible = false;
			}
			resizeFocusTimeMarker();
		}

		private function synchronizeDateLimits():void
		{
			var charts:Vector.<TouchScrollingScrubChart> = _visibleCharts;

			var minimum:Number;
			var maximum:Number;
			var today:Date = model.currentDateSource.now();
			for each (var chart:TouchScrollingScrubChart in charts)
			{
				chart.commitPendingDataChanges();
				if (isNaN(minimum))
					minimum = chart.minimumDataTime;
				else
					minimum = Math.min(minimum, chart.minimumDataTime);

				if (isNaN(maximum))
					maximum = chart.maximumDataTime;
				else
					maximum = Math.max(maximum, chart.maximumDataTime);
			}

			if (!isNaN(minimum) && !isNaN(maximum))
			{
				for each (chart in charts)
				{
					chart.today = today;
					chart.minimumTime = minimum;
					chart.maximumTime = maximum;
					if (chart.allSeriesUpdated())
					{
						// first time initialization complete; nothing else to do
					}
					else //if (chart.focusTime == chart.rightRangeTime == chart.maximumTime)
					{
						chart.rightRangeTime = maximum;
						chart.leftRangeTime = Math.max(minimum, maximum - initialDurationTime);
						chart.updateForScroll();
						chart.focusTime = maximum;
					}
				}
			}

			if (_traceEventHandlers)
				trace("synchronizeDateLimits minimum " + ScrubChart.traceDate(minimum) + " maximum " + ScrubChart.traceDate(maximum));
		}

		protected function updateSeries():void
		{
			for each (var seriesSet:ScrubChartSeriesSet in seriesSets)
			{
				seriesSet.chart.series = new Array();
				for each (var series:Series in seriesSet.series)
				{
					addSeries(seriesSet.chart, series);
				}
			}
		}

		protected function adherenceChart_initializeHandler(event:FlexEvent):void
		{
			// TODO Auto-generated method stub
			if (_traceEventHandlers)
				trace("adherenceChart_initializeHandler");
		}

		protected function heartRateChart_creationCompleteHandler(event:FlexEvent):void
		{
			var chart:ScrubChart = ScrubChart(event.target);

			var verticalAxis:LinearAxis = chart.mainChart.verticalAxis as LinearAxis;
			verticalAxis.minimum = 50;
			verticalAxis.maximum = 100;
		}

		private function updateAdherenceChartSeriesCompleteHandler(chart:ScrubChart, mainCanvas:DataDrawingCanvas,
																   zoneLabel:Label, rangeCanvas:DataDrawingCanvas,
																   medicationCode:String, ndcCode:String):void
		{
			chart.mainChart.backgroundElements.push(mainCanvas);
			drawAdherenceData(mainCanvas, zoneLabel, medicationCode, ndcCode);
			chart.mainChart.invalidateDisplayList();
			chart.mainChart.invalidateSize();

			if (chart.rangeChart)
			{
				chart.rangeChart.backgroundElements.push(rangeCanvas);
				drawAdherenceData(rangeCanvas, null, medicationCode, ndcCode);
			}
		}

		private function checkAllSeriesComplete(series:Series):void
		{
			if (_seriesWithPendingUpdateComplete.contains(series))
			{
				_seriesWithPendingUpdateComplete.removeItemAt(_seriesWithPendingUpdateComplete.getItemIndex(series));
				if (_seriesWithPendingUpdateComplete.length == 0 && _chartsWithPendingCreationComplete.length == 0)
					queueSynchronizeDateLimits();
			}

		}

		private function updateBloodPressureChartBackgroundElements(chart:ScrubChart):void
		{
			chart.mainChart.backgroundElements.push(bloodPressureMainCanvas);
			drawBloodPressureData(bloodPressureMainCanvas);

			if (chart.rangeChart)
			{
				chart.rangeChart.backgroundElements.push(bloodPressureRangeCanvas);
				drawBloodPressureData(bloodPressureRangeCanvas);
			}
		}

		protected override function keyDownHandler(event:KeyboardEvent):void
		{
			if (event.altKey && event.ctrlKey && event.keyCode == Keyboard.F)
			{
				model.showFps = !model.showFps;
			}
			else if (event.altKey && event.ctrlKey)
			{
				switch (event.keyCode)
				{
					case (Keyboard.NUMBER_1):
					{
						this.stage.frameRate = 0;
						break;
					}
					case (Keyboard.NUMBER_2):
					{
						this.stage.frameRate = 24;
						break;
					}
					case (Keyboard.NUMBER_6):
					{
						this.stage.frameRate = 60;
						break;
					}
					case (Keyboard.NUMBER_7):
					{
						this.stage.frameRate = 120;
						break;
					}
					case Keyboard.B:
					{
						runScrollingBenchmark();
						break;
					}
					case Keyboard.R:
					{
						rangeChartVisible = !rangeChartVisible;
						break;
					}
					case Keyboard.H:
					{
						scrollEnabled = !scrollEnabled;
						break;
					}
					case Keyboard.T:
					{
						_traceEventHandlers = !_traceEventHandlers;
						trace("_traceEventHandlers " + _traceEventHandlers);
					}
				}
			}
		}

		private const benchmarkTrialDuration:Number = 2000;
		private var _benchmarkFrameCount:int;
		private var completeTrial:BenchmarkTrial;
		private var synchronizedTrial:BenchmarkTrial;
		private var individualTrials:Vector.<BenchmarkTrial>;
		private var individualChartsQueue:Vector.<TouchScrollingScrubChart>;
		//			private var adherenceTrial:BenchmarkTrial;
		//			private var bloodPressureTrial:BenchmarkTrial;
		//			private var heartRateTrial:BenchmarkTrial;
		public function runScrollingBenchmark():void
		{
			_benchmarkFrameCount = 0;

			var allCharts:Vector.<TouchScrollingScrubChart> = getAllCharts();
			var visibleCharts:Vector.<TouchScrollingScrubChart> = new Vector.<TouchScrollingScrubChart>();
			for each (var chart:TouchScrollingScrubChart in allCharts)
			{
				if (chart.visible)
					visibleCharts.push(chart);
			}
			setSingleChartMode(visibleCharts[0], false);

			visibleCharts = getVisibleCharts(allCharts, null, _singleChartMode, model.showAdherence,
											 model.showHeartRate);

			this.addEventListener(Event.ENTER_FRAME, enterFrameHandler);

			individualTrials = new Vector.<BenchmarkTrial>();
			completeTrial = new BenchmarkTrial();
			completeTrial.name = "Overall";
			individualTrials.push(completeTrial);
			completeTrial.start(_benchmarkFrameCount);
			synchronizedTrial = new BenchmarkTrial();
			synchronizedTrial.name = "Synchronized";
			individualTrials.push(synchronizedTrial);
			synchronizedTrial.start(_benchmarkFrameCount);

			doScrollTest(visibleCharts[0], 1, benchmarkTrialDuration, benchmarkStep2);
		}

		private function benchmarkStep2(event:Event):void
		{
			synchronizedTrial.stop(_benchmarkFrameCount);

			var allCharts:Vector.<TouchScrollingScrubChart> = getAllCharts();
			individualChartsQueue = getVisibleCharts(allCharts, null, _singleChartMode, model.showAdherence,
													 model.showHeartRate);

			startIndividualTrial();
		}

		private function startIndividualTrial():void
		{
			setSingleChartMode(individualChartsQueue[0], true);
			var trial:BenchmarkTrial = new BenchmarkTrial();
			trial.name = individualChartsQueue[0].id;
			individualTrials.push(trial);
			trial.start(_benchmarkFrameCount);
			doScrollTest(individualChartsQueue[0], 1, benchmarkTrialDuration, benchmarkStep3);
		}

		private function stopIndividualTrial():void
		{
			individualTrials[individualTrials.length - 1].stop(_benchmarkFrameCount);
			setSingleChartMode(individualChartsQueue[0], false);
			individualChartsQueue.shift();
		}

		private function benchmarkStep3(event:Event):void
		{
			stopIndividualTrial();

			if (individualChartsQueue.length > 0)
				startIndividualTrial();
			else
			{
				completeTrial.stop(_benchmarkFrameCount);

				traceAndLog("======= Benchmark Results ========");

				//					trace("  Overall:        ", completeTrial.fps.toFixed(2));
				//					trace("  Synchronized:   ", synchronizedTrial.fps.toFixed(2));
				//					trace("  Adherence:      ", adherenceTrial.fps.toFixed(2));
				//					trace("  Blood Pressure: ", bloodPressureTrial.fps.toFixed(2));
				//					trace("  Heart Rate:     ", heartRateTrial.fps.toFixed(2));

				for each (var trial:BenchmarkTrial in individualTrials)
				{
					traceAndLog("  " + StringUtils.padRight(trial.name + ":", " ",
															20) + " " + trial.fps.toFixed(2));
				}
			}
		}

		//			private function benchmarkStep4(event:Event):void
		//			{
		//				bloodPressureTrial.stop(_benchmarkFrameCount);
		//				setSingleChartMode(bloodPressureChart, false);
		//				setSingleChartMode(heartRateChart, true);
		//				heartRateTrial = new BenchmarkTrial();
		//				heartRateTrial.start(_benchmarkFrameCount);
		//				doScrollTest(heartRateChart, 1, 6000, benchmarkStep5);
		//			}

		//			private function benchmarkStep5(event:Event):void
		//			{
		//				heartRateTrial.stop(_benchmarkFrameCount);
		//				setSingleChartMode(heartRateChart, false);
		//
		//			}

		private function doScrollTest(chart:TouchScrollingScrubChart, screensToScroll:Number, timeToScroll:Number,
									  effectEndHandler:Function):void
		{
			var scrollRightAnimate:Animate = new Animate(chart);
			//				scrollRightAnimate.easer = new Power(0.5, 3);
			scrollRightAnimate.easer = new Linear();
			scrollRightAnimate.duration = timeToScroll;
			//				scrollRightAnimate.addEventListener(TweenEvent.TWEEN_UPDATE, function():void { this.validateNow(); });
			//				scrollRightAnimate.addEventListener(EffectEvent.EFFECT_END, effectEndHandler);
			scrollRightAnimate.motionPaths = new Vector.<MotionPath>();

			var scrollRightPath:SimpleMotionPath = new SimpleMotionPath();
			scrollRightPath.property = "contentPositionX";
			//				scrollRightPath.valueFrom = -chart.scrollableAreaWidth + chart.panelWidth;
			scrollRightPath.valueFrom = chart.contentPositionX;
			scrollRightPath.valueTo = scrollRightPath.valueFrom + chart.panelWidth * screensToScroll;
			scrollRightAnimate.motionPaths.push(scrollRightPath);

			var scrollLeftAnimate:Animate = new Animate(chart);
			//				scrollLeftAnimate.easer = new Power(0.5, 3);
			scrollLeftAnimate.easer = new Linear();
			scrollLeftAnimate.duration = timeToScroll;
			//				scrollLeftAnimate.addEventListener(EffectEvent.EFFECT_END, effectEndHandler);
			scrollLeftAnimate.motionPaths = new Vector.<MotionPath>();

			var scrollLeftPath:SimpleMotionPath = new SimpleMotionPath();
			scrollLeftPath.property = "contentPositionX";
			scrollLeftPath.valueTo = scrollRightPath.valueFrom;
			scrollLeftAnimate.motionPaths.push(scrollLeftPath);

			var sequence:Sequence = new Sequence(chart);
			sequence.addChild(scrollRightAnimate);
			sequence.addChild(scrollLeftAnimate);
			sequence.addEventListener(EffectEvent.EFFECT_END, effectEndHandler);

			sequence.play();
		}

		private function enterFrameHandler(event:Event):void
		{
			_benchmarkFrameCount++;
		}

		private var _singleChartMode:Boolean = false;
		private var _chartFooterVisible:Boolean = true;

		protected function chart_doubleClickHandler(event:MouseEvent):void
		{
			var targetChart:TouchScrollingScrubChart = TouchScrollingScrubChart(event.currentTarget);

			setSingleChartMode(targetChart, !_singleChartMode);
		}

		protected function setSingleChartMode(targetChart:TouchScrollingScrubChart, mode:Boolean):void
		{
			_singleChartMode = mode;

			_scrollTargetChart = null;
			updateChartsCache(targetChart);

			var allCharts:Vector.<TouchScrollingScrubChart> = getAllCharts();
			for (var i:int = 0; i < _visibleCharts.length; i++)
			{
				var chart:TouchScrollingScrubChart = _visibleCharts[i] as TouchScrollingScrubChart;

				// middle chart
				chart.setStyle("headerVisible", false);
				chart.setStyle("footerVisible", false);
				chart.setStyle("sliderVisible", false);
				chart.setStyle("topBorderVisible", true);
				chart.setStyle("rangeChartVisible", rangeChartVisible);

				if (i == 0)
				{
					// top chart
					chart.setStyle("topBorderVisible", true);
				}

				if (i == _visibleCharts.length - 1)
				{
					// bottom chart
					chart.setStyle("footerVisible", chartFooterVisible);
				}
			}

			for each (chart in allCharts)
			{
				var visible:Boolean = _visibleCharts.indexOf(chart) != -1;
				chart.visible = visible;
				chart.includeInLayout = visible;
			}

			if (_visibleCharts.length > 1 && targetChart != null)
			{
				var nonTargetCharts:Vector.<TouchScrollingScrubChart> = getVisibleNonTargetCharts(_visibleCharts,
																								  targetChart);
				synchronizeScrollPositions(targetChart, nonTargetCharts);
				synchronizeFocusTimes(targetChart, nonTargetCharts);
			}
		}

		protected function getAllCharts():Vector.<TouchScrollingScrubChart>
		{
			var allCharts:Vector.<TouchScrollingScrubChart> = new Vector.<TouchScrollingScrubChart>();
			/*
			 if (chartsGroup)
			 {
			 for (var i:int = 0; i < chartsGroup.numElements; i++)
			 {
			 var chart:TouchScrollingScrubChart;
			 var group:GroupBase = chartsGroup.getElementAt(i) as GroupBase;
			 if (group)
			 chart = group.getElementAt(1) as TouchScrollingScrubChart;
			 else
			 chart = chartsGroup.getElementAt(i) as TouchScrollingScrubChart;

			 if (chart != null)
			 allCharts.push(chart);
			 }
			 }
			 */
			for each (var chart:TouchScrollingScrubChart in _adherenceCharts.values())
			{
				allCharts.push(chart);
			}
			allCharts.push(bloodPressureChart);
			return allCharts;
		}

		protected function getVisibleCharts(allCharts:Vector.<TouchScrollingScrubChart>,
											targetChart:TouchScrollingScrubChart, singleChartMode:Boolean,
											showAdherence:Boolean,
											showHeartRate:Boolean):Vector.<TouchScrollingScrubChart>
		{
			var visibleCharts:Vector.<TouchScrollingScrubChart> = new Vector.<TouchScrollingScrubChart>();
			for each (var chart:TouchScrollingScrubChart in allCharts)
			{
				if (singleChartMode)
				{
					if (chart == targetChart)
						visibleCharts.push(chart);
				}
				else if (chart != bloodPressureChart)
				{
					if (showAdherence)
						visibleCharts.push(chart);
				}
				//				else if (chart == heartRateChart)
				//				{
				//					if (showHeartRate)
				//						visibleCharts.push(chart);
				//				}
				else
				{
					visibleCharts.push(chart);
				}
			}
			return visibleCharts;
		}

		protected function getVisibleNonTargetCharts(visibleCharts:Vector.<TouchScrollingScrubChart>,
													 targetChart:TouchScrollingScrubChart):Vector.<TouchScrollingScrubChart>
		{
			var visibleNonTargetCharts:Vector.<TouchScrollingScrubChart> = new Vector.<TouchScrollingScrubChart>();
			for each (var chart:TouchScrollingScrubChart in visibleCharts)
			{
				if (chart != targetChart)
				{
					visibleNonTargetCharts.push(chart);
				}
			}
			return visibleNonTargetCharts;
		}

		private var _scrollTargetChart:TouchScrollingScrubChart;
		private var _nonTargetCharts:Vector.<TouchScrollingScrubChart>;
		private var _visibleCharts:Vector.<TouchScrollingScrubChart>;
		private var skipUpdateSimulation:Boolean = false;
		private var shouldApplyChangesToSimulation:Boolean = true;
		private var _isSeriesSetsInitialized:Boolean;
		private var _pendingUpdateSimulation:TouchScrollingScrubChart;

		protected function chart_scrollHandler(event:ScrollEvent):void
		{
			var targetChart:TouchScrollingScrubChart = TouchScrollingScrubChart(event.currentTarget);
			updateChartsCache(targetChart);

			if (!_singleChartMode)
			{
				synchronizeScrollPositions(targetChart, _nonTargetCharts);
			}

			queueUpdateSimulation(targetChart);
		}

		protected function synchronizeScrollPositions(targetChart:TouchScrollingScrubChart,
													  otherCharts:Vector.<TouchScrollingScrubChart>):void
		{
			for each (var otherChart:TouchScrollingScrubChart in otherCharts)
			{
				if (otherChart.visible)
				{
					otherChart.stopInertiaScrolling();
					otherChart.leftRangeTime = targetChart.leftRangeTime;
					otherChart.rightRangeTime = targetChart.rightRangeTime;
					otherChart.updateForScroll();
				}
			}
		}

		protected function synchronizeFocusTimes(targetChart:TouchScrollingScrubChart,
												 otherCharts:Vector.<TouchScrollingScrubChart>):void
		{
			for each (var otherChart:TouchScrollingScrubChart in otherCharts)
			{
				if (otherChart.visible)
				{
					//						otherChart.stopInertiaScrolling();
					//						otherChart.leftRangeTime = targetChart.leftRangeTime;
					//						otherChart.rightRangeTime = targetChart.rightRangeTime;
					//						otherChart.updateForScroll();
					otherChart.focusTime = targetChart.focusTime;
				}
			}
		}

		protected function chart_scrollStartHandler(event:TouchScrollerEvent):void
		{
			var targetChart:TouchScrollingScrubChart = TouchScrollingScrubChart(event.currentTarget);

			if (_traceEventHandlers)
				trace(this.id + ".chart_scrollStartHandler " + targetChart.id);
		}

		protected function chart_scrollStopHandler(event:TouchScrollerEvent):void
		{
			var targetChart:TouchScrollingScrubChart = TouchScrollingScrubChart(event.currentTarget);

			if (_traceEventHandlers)
				trace(this.id + ".chart_scrollStopHandler " + targetChart.id);
		}

		protected function chart_focusTimeChangeHandler(event:FocusTimeEvent):void
		{
			var targetChart:TouchScrollingScrubChart = TouchScrollingScrubChart(event.currentTarget);

			updateChartsCache(targetChart);

			if (!_singleChartMode)
			{
				synchronizeFocusTimes(targetChart, _nonTargetCharts);
			}

			queueUpdateSimulation(targetChart);
		}

		private function queueUpdateSimulation(targetChart:TouchScrollingScrubChart):void
		{
			_pendingUpdateSimulation = targetChart;
			invalidateProperties();
		}

		private function updateChartsCache(targetChart:TouchScrollingScrubChart):void
		{
			if (targetChart == null || _scrollTargetChart != targetChart)
			{
				var allCharts:Vector.<TouchScrollingScrubChart> = getAllCharts();
				_visibleCharts = getVisibleCharts(allCharts, targetChart, _singleChartMode, model.showAdherence,
												  model.showHeartRate);
				_nonTargetCharts = getVisibleNonTargetCharts(_visibleCharts, targetChart);
				_scrollTargetChart = targetChart;
			}
		}

		override protected function commitProperties():void
		{
			super.commitProperties();

			if (_pendingSynchronizeDateLimits)
			{
				synchronizeDateLimits();
				_pendingSynchronizeDateLimits = false;
			}
			if (_pendingUpdateSimulation)
			{
				updateSimulation(_pendingUpdateSimulation);
				_pendingUpdateSimulation = null;
			}
		}

		private function updateSimulation(targetChart:TouchScrollingScrubChart):void
		{
			if (skipUpdateSimulation)
				return;

			if (shouldApplyChangesToSimulation)
				model.focusSimulation.date = new Date(targetChart.focusTime);

			var bloodPressureDataPoint:VitalSign;
			var series:Series = bloodPressureChart.mainChart.series[0];
			if (series)
			{
				var dataCollection:ArrayCollection = series.dataProvider as ArrayCollection;
				var bloodPressureDataIndex:int = bloodPressureChart.findPreviousDataIndex(dataCollection,
																						  model.focusSimulation.date.time);
				if (bloodPressureDataIndex != -1)
				{
					bloodPressureDataPoint = dataCollection.getItemAt(bloodPressureDataIndex) as VitalSign;
					series.selectedIndex = bloodPressureDataIndex;
					if (series.items)
					{
						var chartItem:ChartItem = series.items[bloodPressureDataIndex] as ChartItem;
						if (chartItem)
							bloodPressureChart.highlightChartItem(chartItem);
					}
				}
			}

			if (shouldApplyChangesToSimulation)
			{
				model.focusSimulation.dataPointDate = bloodPressureDataPoint == null ? null : bloodPressureDataPoint.dateMeasuredStart;
				model.focusSimulation.systolic = bloodPressureDataPoint == null ? NaN : bloodPressureDataPoint.resultAsNumber;
			}
			// TODO: fix diastolic
//			model.simulation.diastolic = bloodPressureDataPoint == null ? NaN : bloodPressureDataPoint.diastolic;

			var hypertensionSeverity:Number = 0;
			if (!isNaN(model.focusSimulation.systolic))
			{
				hypertensionSeverity = Math.max(0, (model.focusSimulation.systolic - 120) / 20);
			}

			//				simulationGlow.alpha = hypertensionSeverity;

			if (model.isAdherenceLoaded)
			{
				for each (var medicationCode:String in _adherenceCharts.arrayOfKeys)
				{
					updateSimulationMedicationModel(medicationCode);
				}
			}

			if (shouldApplyChangesToSimulation && targetChart.isFocusOnMaximumTime)
			{
				model.focusSimulation.mode = SimulationModel.MOST_RECENT_MODE;
			}
			else
			{
				model.focusSimulation.mode = SimulationModel.HISTORY_MODE;
			}

			if (_traceEventHandlers)
				trace("updateSimulation " + targetChart.id + " dateMeasuredStart " + ScrubChart.traceDate(model.focusSimulation.dataPointDate.time) + " systolic " + model.focusSimulation.systolic);
		}

		public function get chartsOnlyViewMode():Boolean
		{
			return _chartsOnlyViewMode;
		}

		public function set chartsOnlyViewMode(value:Boolean):void
		{
			_chartsOnlyViewMode = value;
		}

		protected function simulationView_doubleClickHandler(event:MouseEvent):void
		{
			simulationOnlyViewMode = !simulationOnlyViewMode;
			updateComponentsForSimulationOnlyViewMode();
		}

		private function updateComponentsForSimulationOnlyViewMode():void
		{
			if (simulationOnlyViewMode)
			{
				chartsGroup.percentWidth = 0;
				chartsGroup.visible = false;
				simulationGroup.width = NaN;
				simulationGroup.percentWidth = 100;
				simulationGroup.visible = true;
			}
			else if (chartsOnlyViewMode)
			{
				chartsGroup.percentWidth = 100;
				chartsGroup.visible = true;
				simulationGroup.width = NaN;
				simulationGroup.percentWidth = 0;
				simulationGroup.visible = false;
			}
			else
			{
				chartsGroup.percentWidth = 100;
				chartsGroup.visible = true;
				simulationGroup.percentWidth = NaN;
				simulationGroup.width = SIMULATION_VIEW_WIDTH + simulationGroup.paddingLeft + simulationGroup.paddingRight;
				simulationGroup.visible = true;
			}
		}

		public function get chartFooterVisible():Boolean
		{
			return _chartFooterVisible;
		}

		public function set chartFooterVisible(value:Boolean):void
		{
			_chartFooterVisible = value;
		}

		[Bindable]
		public function get initialDurationTime():Number
		{
			return _initialDurationTime;
		}

		public function set initialDurationTime(value:Number):void
		{
			_initialDurationTime = value;
		}

		private function traceAndLog(message:String):void
		{
			trace(message);
			logger.info(message);
		}

		private function updateRangeChartVisibleStyles():void
		{
			for each (var chart:ScrubChart in getAllCharts())
			{
				chart.setStyle("rangeChartVisible", rangeChartVisible);
			}
		}

		private function initializeSeriesSets():void
		{
			_seriesWithPendingUpdateComplete.addItem(systolicSeries);
			_seriesWithPendingUpdateComplete.addItem(diastolicSeries);

			if (!_isSeriesSetsInitialized)
			{
				_isSeriesSetsInitialized = true;
				bloodPressureChart.addDataSet(model.systolicData, "dateMeasuredStart");
				bloodPressureChart.addDataSet(model.diastolicData, "dateMeasuredStart");

				var seriesSet:ScrubChartSeriesSet;

				seriesSet = new ScrubChartSeriesSet();
				seriesSet.chart = bloodPressureChart.mainChart;
				seriesSet.series.push(systolicSeries);
				seriesSet.series.push(diastolicSeries);
				seriesSets.push(seriesSet);

				if (bloodPressureChart.rangeChart)
				{
					seriesSet = new ScrubChartSeriesSet();
					seriesSet.chart = bloodPressureChart.rangeChart;
					seriesSet.series.push(systolicRangeSeries);
					seriesSet.series.push(diastolicRangeSeries);
					seriesSets.push(seriesSet);
				}
			}
		}

		[Bindable]
		public function get useHorizontalTouchScrolling():Boolean
		{
			return _useHorizontalTouchScrolling;
		}

		public function set useHorizontalTouchScrolling(value:Boolean):void
		{
			_useHorizontalTouchScrolling = value;
		}

		private function bloodPressureChart_mainChart_resizeHandler(event:ResizeEvent):void
		{
			resizeFocusTimeMarker();
		}

		private function getMedicationColor(ndcCode:String):uint
		{
			var color:uint;
			if (_medicationColorSource)
				color = _medicationColorSource.getMedicationColor(ndcCode);

			if (color == 0)
				color = 0x4252A4;

			return color;
		}

		public function get modality():String
		{
			return _modality;
		}

		public function set modality(value:String):void
		{
			_modality = value;
		}

		public function updateSimulationMedicationModel(medicationCode:String):void
		{
			var medicationModel:MedicationComponentAdherenceModel = model.focusSimulation.getMedication(medicationCode);

			if (medicationModel == null)
			{
				trace("Warning: No medication found in the model.simulation for key " + medicationCode + ". This will happen if there are no MedicationAdministration documents in the record for this medication.");
			}
			else
			{
				var currentAdherenceChart:ScrubChart = _adherenceCharts.getValueByKey(medicationCode);

				var concentrationDataPoint:MedicationConcentrationSample;
				var series:Series = currentAdherenceChart.mainChart.series[0];
				if (series)
				{
					var dataCollection:ArrayCollection = series.dataProvider as ArrayCollection;
					var concentrationDataIndex:int = currentAdherenceChart.findPreviousDataIndex(dataCollection,
																								 model.focusSimulation.date.time);
					if (concentrationDataIndex != -1)
					{
						concentrationDataPoint = dataCollection.getItemAt(concentrationDataIndex) as MedicationConcentrationSample;
						series.selectedIndex = concentrationDataIndex;
						if (series.items)
						{
							var chartItem:ChartItem = series.items[concentrationDataIndex] as ChartItem;
							if (chartItem)
								currentAdherenceChart.highlightChartItem(chartItem);
						}
					}
				}

				// TODO: show the date for the concentration data point
				var concentration:Number = concentrationDataPoint == null ? 0 : concentrationDataPoint.concentration;

				if (shouldApplyChangesToSimulation)
					medicationModel.concentration = concentration;
			}
		}

		private function resizeFocusTimeMarker():void
		{
			bloodPressureChart.focusTimeMarker.y = -bloodPressureGroup.y;
			bloodPressureChart.focusTimeMarker.height = chartsGroup.height - bloodPressureChart.footer.height;
		}

		private function chartsGroup_resizeHandler(event:ResizeEvent):void
		{
			resizeFocusTimeMarker();
		}
		]]></fx:Script>

	<mx:HDividedBox height="100%" width="100%" paddingRight="0" clipContent="true" horizontalScrollPolicy="off"
					verticalScrollPolicy="off" backgroundColor="#F1F2F2"
					dividerSkin="collaboRhythm.shared.view.skins.FlatRectBoxDividerSkin">


		<s:VGroup id="leftGroup" height="100%" width="100%" gap="15" paddingLeft="0" paddingRight="0" paddingTop="0"
				  paddingBottom="0">

<!--
			<s:Group width="100%">
				<buttons:ContentLabel
						id="hypertensionTitle" horizontalCenter="0"
						width="400" height="60"
						text="Hypertension"
						>
					<buttons:leftContent>
						<simulation:ProblemsIcon left="15" verticalCenter="0"/>
					</buttons:leftContent>
					<buttons:rightContent>
						<simulation:HypertensionGauge id="hypertensionGauge" right="10" verticalCenter="0"
													  value="{model.simulation.systolic}"/>
					</buttons:rightContent>
				</buttons:ContentLabel>
			</s:Group>
-->

			<s:VGroup id="chartsGroup" height="100%" width="100%" gap="10" paddingLeft="0" paddingRight="0"
					  paddingTop="0"
					  paddingBottom="8"
					  resize="chartsGroup_resizeHandler(event)"
					>
				<s:HGroup id="bloodPressureGroup" height="100%" width="100%" gap="0" minHeight="300">
					<s:Group height="100%">
						<images:BloodPressureScheduleItemClockView width="100" height="100" verticalCenter="0"/>
					</s:Group>
					<controls:TouchScrollingScrubChart id="bloodPressureChart"
													   skinClass="com.dougmccune.controls.ScrubChartMinimalSkin"
													   height="100%" width="100%"
													   creationComplete="bloodPressureChart_creationCompleteHandler(event)"
													   topBorderVisible="false"
													   sliderVisible="false"
													   mainChartTitle="Blood Pressure (mmHg)"
													   seriesName="resultAsNumber"
													   data="{model.isInitialized ? model.systolicData : null}"
													   dateField="dateMeasuredStart"
													   today="{model.currentDateSource.now()}"
													   showFps="{model.showFps}"
													   scroll="chart_scrollHandler(event)"
													   scrollStart="chart_scrollStartHandler(event)"
													   scrollStop="chart_scrollStopHandler(event)"
													   focusTimeChange="chart_focusTimeChangeHandler(event)"
													   initialDurationTime="{initialDurationTime}"
													   showFocusTimeMarker="{showFocusTimeMarker}"
													   scrollEnabled="{scrollEnabled}"
													   synchronizedAxisCache="{synchronizedAxisCache}"
													   useHorizontalTouchScrolling="{useHorizontalTouchScrolling}"
							/>
				</s:HGroup>
			</s:VGroup>
		</s:VGroup>
		<s:VGroup id="simulationGroup" height="100%" gap="15" paddingLeft="0" paddingRight="0" paddingTop="5"
				  clipAndEnableScrolling="true"
				  paddingBottom="8"
				  width="{SIMULATION_VIEW_WIDTH + simulationGroup.paddingLeft + simulationGroup.paddingRight}"
				> <!-- TODO: paddingBottom should be the same as the chartsGroup, but one or both of these components have some internal padding (the ScrubChart currently has an extra 15 paddingBottom "built in" to the footer) -->
			<simulation:SimulationView id="simulationView" height="100%" width="100%"
					/>
			<!--
			   doubleClickEnabled="true"
										  doubleClick="simulationView_doubleClickHandler(event)"
   -->
		</s:VGroup>
	</mx:HDividedBox>
</s:Group>
