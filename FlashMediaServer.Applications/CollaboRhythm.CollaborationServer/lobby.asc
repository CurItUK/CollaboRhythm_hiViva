application.onAppStart = function ( ) { 

	// Hash table to keep track of all of the clients connected by username
	application.connectedAccountIds = new Object();
	application.connectedClientCount = 0;
	// Redundant shared object for debugging purposes with Flash Media Server Administration Console
	application.connectedAccountIds_so = SharedObject.get("private/connectedAccountIds");

	// Retrieve the last used roomID from a persistent private shared object.
	application.lastRoomNumber_so = SharedObject.get("private/lastRoomNumber", true);
  	if (application.lastRoomNumber_so.size( ) == 0) 
	{
    	application.lastRoomNumber = 0;
    	application.lastRoomNumber_so.setProperty("number", application.lastRoomNumber);
  	}
	else
	{
  		application.lastRoomNumber = this.lastRoomNumber_so.getProperty("number");
	}

	trace("lobby started");
	trace("lastRoomNumber: " + application.lastRoomNumber);
};

function getCollaborationRoomID () {
  trace("createCollaborationRoom");

  // Increment the lastRoomID counter and save it in the shared object.
  application.lastRoomNumber++;
  application.lastRoomNumber_so.setProperty("id", application.lastRoomID);

  // Create a unique room ID
  var roomID = "c" + application.lastRoomNumber + "r" + Math.round(Math.random( )*1000);

  trace("New Room Created:" + roomID);
  
  return roomID;
}

function sendCollaborationRequest (sourceUserName, targetUserName, roomID, passWord, creatingUserName, subjectUserName)
{
	application.connectedAccountIds[targetUserName].call("receiveCollaborationRequest", null, sourceUserName, roomID, passWord, creatingUserName, subjectUserName);
}

function sendSynchronizationMessage(targetUserName)
{
	var clients = application.connectedAccountIds[targetUserName];
	for (var clientIndex = 0; clientIndex < clients.length; clientIndex++)
	{
		var client = clients[clientIndex];
		if (client != this)
		{
			client.call("receiveSynchronizationMessage", null);
		}
	}
}

// handler for client to server function that allows a client to report a status update to all remote users
// statusUpdate is an Object {userName: "user's unique e-mail address", userStatus: "user's status"}
function updateCollaborationLobbyConnectionStatus(userName, connectionStatus)
{
	var clients = application.connectedAccountIds[userName];
	for (var clientIndex = 0; clientIndex < clients.length; clientIndex++)
	{
		var client = clients[clientIndex];
		if (client != null)
		{
			client.connectionStatus = connectionStatus;
			client.call("localUserCollaborationLobbyConnectionStatusChanged", null, connectionStatus);
			updateUsers(client, "updateConnectionStatus");
		}
	}
}

// update the newly connected client of the status of all of the remote users
// update all of the remote users of the newly connected client
function updateUsers(client, action)
{
	var allSharingAccountIds = client.allSharingAccountIds;
	for (var sharingAccountIdIndex = 0; sharingAccountIdIndex < allSharingAccountIds.length; sharingAccountIdIndex++) {
		var sharingAccountId = allSharingAccountIds[sharingAccountIdIndex];
		var sharingAccountIdClients = application.connectedAccountIds[sharingAccountId];
		if (sharingAccountIdClients != null)
		{
			for (var clientIndex = 0; clientIndex < sharingAccountIdClients.length; clientIndex++)
			{
				var sharingAccountIdClient = sharingAccountIdClients[clientIndex];
				if (action == "entered")
				{
					client.call("sharingAccountCollaborationLobbyConnectionStatusChanged", null, sharingAccountId, sharingAccountIdClient.connectionStatus);
				}
				sharingAccountIdClient.call("sharingAccountCollaborationLobbyConnectionStatusChanged", null, client.accountId, client.connectionStatus);
			}
		}
	}
}

// is called when a new client connects to the server
application.onConnect = function (client, accountId, connectionStatus, allSharingAccountIds) {

	// accept the client
	trace("client connected to lobby: " + accountId);
	application.acceptConnection(client);
	application.connectedClientCount += 1;

	// if an accountId is not already connected, created a new array of clients including the current client
	// otherwise just add the current client to the existing array
	var isAccountIdConnected = application.connectedAccountIds_so.getProperty(accountId);
	if (!isAccountIdConnected)
	{
		application.connectedAccountIds[accountId] = [client];
	}
	else
	{
		application.connectedAccountIds[accountId].push(client);
	}

	// only allow the client to access videos from records that have been shared its corresponding account
	var readAccessString = accountId;
	var writeAccessString = accountId;
	
	for (var sharingAccountIdIndex = 0; sharingAccountIdIndex < allSharingAccountIds.length; sharingAccountIdIndex++) {

		var sharingAccountId = allSharingAccountIds[sharingAccountIdIndex];
		readAccessString += "; " + sharingAccountId;
		writeAccessString += "; " + sharingAccountId;
	}
	
	client.readAccess = readAccessString;
	client.writeAccess = writeAccessString;

	client.accountId = accountId;
	client.connectionStatus = connectionStatus;
	client.allSharingAccountIds = allSharingAccountIds;

	// the redundant connectedAccountIds shared object is used for debugging purposes with the Flash Media Server Administration Console
	var accountData = new Object();
	accountData["connectionStatus"] = connectionStatus;
	accountData["allSharingAccountIds"] = allSharingAccountIds;
	application.connectedAccountIds_so.setProperty(accountId, accountData);

	// client to server function that allows a client to report a status update to other users
	client.updateCollaborationLobbyConnectionStatus = updateCollaborationLobbyConnectionStatus;
	
	// client to server function that allows a client to request a connection with a shared user
	client.sendCollaborationRequest = sendCollaborationRequest;

	// client to server function that allows a client to request a client to synchronize its data with the Indivo server
	client.sendSynchronizationMessage = sendSynchronizationMessage;
	
	client.getCollaborationRoomID = getCollaborationRoomID;

	// update the newly connected client of the status of all of the shared users
	// update all of the shared users of the newly connected client
	client.call("activeAccountCollaborationLobbyConnectionStatusChanged", null, client.connectionStatus);
	updateUsers(client, "entered");

	return true;
};

// Delete records of clients when they disconnect.
application.onDisconnect = function (client) {
	trace("client disconnected from lobby: " + client.accountId);
	
	application.connectedAccountIds[client.accountId] = null;
	application.connectedClientCount -= 1;
	application.connectedAccountIds_so.setProperty(client.accountId, null);
};