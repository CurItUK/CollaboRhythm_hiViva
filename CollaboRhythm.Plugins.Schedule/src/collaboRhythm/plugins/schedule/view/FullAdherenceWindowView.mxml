<?xml version="1.0" encoding="utf-8"?>
<!--~
  ~ Copyright 2011 John Moore, Scott Gilroy
  ~
  ~ This file is part of CollaboRhythm.
  ~
  ~ CollaboRhythm is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
  ~ License as published by the Free Software Foundation, either version 2 of the License, or (at your option) any later
  ~ version.
  ~
  ~ CollaboRhythm is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
  ~ warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
  ~ details.
  ~
  ~ You should have received a copy of the GNU General Public License along with CollaboRhythm.  If not, see
  ~ <http://www.gnu.org/licenses/>.
  -->
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx"
		 x="{determineXPosition(_scheduleModel.timeWidth, _adherenceGroup.adherenceWindow, _adherenceGroup.hour)}"
		 bottom="0" alpha="0.5">
	<fx:Declarations>
		<s:Animate id="resizeEffect" target="{this}">
			<s:motionPaths>
				<s:SimpleMotionPath id="resizeMotionPath" property="height"/>
			</s:motionPaths>
		</s:Animate>
	</fx:Declarations>
	<fx:Script>
		<![CDATA[		
			import collaboRhythm.plugins.schedule.shared.model.AdherenceGroup;
			import collaboRhythm.plugins.schedule.shared.model.MoveData;
			import collaboRhythm.plugins.schedule.shared.model.ScheduleModel;
			
			import mx.binding.utils.BindingUtils;
			import mx.binding.utils.ChangeWatcher;
			import mx.events.EffectEvent;
			import mx.managers.CursorManagerPriority;
			
			import resources.physics.AccelerationEaser;
			
			import spark.primitives.BitmapImage;
			
			private var _startX:Number;
			private var _startAdherenceWindow:Number;
			private var _resizeBarDragging:String
			private var _mouseDown:Boolean = false;
			private var _mouseOverResizeBar:Boolean = false;
			private var _adherenceWindowRaw:Number;
			
			[Bindable]
			private var _adherenceGroup:AdherenceGroup;
			[Bindable]
			private var _scheduleModel:ScheduleModel;
			[Bindable]
			private var _scheduleFullView:ScheduleFullView;
			private var _changeWatchers:Vector.<ChangeWatcher> = new Vector.<ChangeWatcher>;
			private var _scheduleItemCanvasHeight:Number = 0;
			
			[Embed("/assets/cursors/horizontalResize.png")]
			private var _horizontalResizeCursorClass:Class;
			
			public function get adherenceGroup():AdherenceGroup
			{
				return _adherenceGroup;
			}
			
			public function set adherenceGroup(value:AdherenceGroup):void
			{
				_adherenceGroup = value;
				_adherenceWindowRaw = _adherenceGroup.adherenceWindow;
				var stackingUpdatedChangeWatcher:ChangeWatcher = BindingUtils.bindSetter(animateAdherenceWindowViewHeight, _adherenceGroup, "stackingUpdated");
				_changeWatchers.push(stackingUpdatedChangeWatcher);
			}
			
			public function set scheduleModel(value:ScheduleModel):void
			{
				_scheduleModel = value;
			}
			
			public function set scheduleFullView(value:ScheduleFullView):void
			{
				_scheduleFullView = value;
			}
			
			public function get changeWatchers():Vector.<ChangeWatcher>
			{
				return _changeWatchers;
			}
			
			public function set changeWatchers(value:Vector.<ChangeWatcher>):void
			{
				_changeWatchers = value;
			}
			
			public function unwatchAll():void
			{
				for each (var changeWatcher:ChangeWatcher in _changeWatchers)
				{
					changeWatcher.unwatch();
				}
			}
			
			private function determineXPosition(timeWidth:Number, adherenceWindow:Number, hour:Number):Number
			{
				this.width = Math.floor(adherenceWindow * timeWidth * 2);
				
				return Math.floor((hour + 1) * timeWidth + (timeWidth / 2) - (this.width / 2));
			}
						
			private function animateAdherenceWindowViewHeight(stackingUpdated:Boolean):void
			{
				if (stackingUpdated == true)
				{
					resizeMotionPath.valueFrom = this.height;
					resizeMotionPath.valueTo = calculateHeight();
					if (resizeMotionPath.valueTo < resizeMotionPath.valueFrom)
					{
						var resizeEffectEaser:AccelerationEaser = new AccelerationEaser(this.height - calculateHeight(), AccelerationEaser.gravity * ScheduleFullView.FRICTION);
						resizeEffect.easer = resizeEffectEaser;
						resizeEffect.duration = resizeEffectEaser.duration;
					}
					else
					{
						resizeEffect.easer = null;
						resizeEffect.duration = ScheduleFullView.DURATION;
					}
					resizeEffect.addEventListener(EffectEvent.EFFECT_END, resizeEffectEnd);
					resizeEffect.play();
				}
			}
			
			public function calculateHeight():Number
			{
				//TODO: Fix static reference to medication size
				return Math.floor(ScheduleFullView.TIMELINE_VIEW_HEIGHT + ScheduleFullView.ADHERENCE_WINDOW_INITIAL_HEIGHT + (_adherenceGroup.stackNumber + 1) * FullAdherenceGroupView.ADHERENCE_GROUP_BUFFER_WIDTH + _adherenceGroup.scheduleItemsStacked * (100 + FullAdherenceGroupView.ADHERENCE_GROUP_BUFFER_WIDTH) + _adherenceGroup.adherenceGroupsStacked * FullAdherenceGroupView.ADHERENCE_GROUP_TOP_WIDTH);
			}
			
			private function resizeEffectEnd(event:EffectEvent):void
			{
				_adherenceGroup.stackingUpdated = false;
				_adherenceGroup.yMovement = 0;
			}
			
			private function showResizeCursor(event:MouseEvent):void
			{
				if (_scheduleModel.locked == false) 
				{
					//TODO: Determine how to compute the center of the cursor rather than hard coding numbers
					cursorManager.setCursor(_horizontalResizeCursorClass as Class, CursorManagerPriority.MEDIUM, -12, -12);
					_mouseOverResizeBar = true;
				}
			}
			
			private function hideResizeCursor(event:MouseEvent):void
			{
				if (_scheduleModel.locked == false) 
				{
					if (_mouseDown == false)
					{
						cursorManager.removeAllCursors();
					}
					_mouseOverResizeBar = false;
				}
			}
			
			private function leftResizeBarBeginDrag(event:MouseEvent):void
			{
				_resizeBarDragging = "left";
				resizeBarBeginDrag(event);
			}
			
			private function rightResizeBarBeginDrag(event:MouseEvent):void
			{
				_resizeBarDragging = "right";
				resizeBarBeginDrag(event);
			}
			
			private function resizeBarBeginDrag(event:MouseEvent):void
			{
				if (_scheduleModel.locked == false) 
				{
					_startX = event.stageX;
					_startAdherenceWindow = _adherenceGroup.adherenceWindow;
					_mouseDown = true;
					
					_scheduleFullView.addEventListener(MouseEvent.MOUSE_MOVE, analyzeDrag);
					stage.addEventListener(MouseEvent.MOUSE_UP, endDrag);
				}
			}
			
			private function analyzeDrag(event:MouseEvent):void
			{				
				if (_scheduleModel.locked == false) 
				{
					var adherenceWindow:Number;
					if (_resizeBarDragging == "left")
					{
						adherenceWindow = _startAdherenceWindow - Math.round((event.stageX - _startX) / _scheduleModel.timeWidth);
					}
					else if (_resizeBarDragging == "right")
					{
						adherenceWindow = _startAdherenceWindow + Math.round((event.stageX - _startX) / _scheduleModel.timeWidth);
					}
					
					if (adherenceWindow >= 1 && adherenceWindow <=4)
					{
						var moveData:MoveData = new MoveData();
						moveData.itemIndex = _scheduleModel.adherenceGroupsCollection.getItemIndex(this.adherenceGroup);
						moveData.adherenceWindow = adherenceWindow;
						dispatchEvent(new FullScheduleItemViewEvent(FullScheduleItemViewEvent.ADHERENCE_WINDOW_RESIZE, moveData));
					}
					
				}
			}
			
			private function endDrag(event:MouseEvent):void
			{
				if (_scheduleModel.locked == false && event.eventPhase == EventPhase.BUBBLING_PHASE) 
				{
					_scheduleFullView.removeEventListener(MouseEvent.MOUSE_MOVE, analyzeDrag);
					stage.removeEventListener(MouseEvent.MOUSE_UP, endDrag);
					
					if (_mouseOverResizeBar == false)
					{
						cursorManager.removeAllCursors();
					}
					_mouseDown = false;
				}
			}
			
			private function resizeAdherenceWindow(event:TransformGestureEvent):void
			{
				_adherenceWindowRaw *= event.scaleX;
				var adherenceWindowRounded:Number = Math.round(_adherenceWindowRaw);
				if (adherenceWindowRounded > 4)
				{
					adherenceWindowRounded = 4;
				}
				if (adherenceWindowRounded < 1)
				{
					adherenceWindowRounded = 1;
				}
				if (adherenceWindowRounded != _adherenceGroup.adherenceWindow)
				{
					var moveData:MoveData = new MoveData();
					moveData.itemIndex = _scheduleModel.adherenceGroupsCollection.getItemIndex(this.adherenceGroup);
					moveData.adherenceWindow = adherenceWindowRounded;
					dispatchEvent(new FullScheduleItemViewEvent(FullScheduleItemViewEvent.ADHERENCE_WINDOW_RESIZE, moveData));
				}
			}
		]]>
	</fx:Script>
	<s:Group width="100%" height="100%" gestureZoom="resizeAdherenceWindow(event)">
		<s:Path id="spotlightTrapezoid" data="M 45 0 L 55 0 L 100 50 L 0 50 z" width="100%" bottom="{ScheduleFullView.TIMELINE_VIEW_HEIGHT}" top="0">  
			<s:fill>  
				<s:SolidColor color="0xFFFFFF" />  
			</s:fill>  
		</s:Path>
		<s:Rect id="spotlightRectangle" width="100%" height="{ScheduleFullView.TIMELINE_VIEW_HEIGHT}" bottom="0">
			<s:fill>  
				<s:SolidColor color="0xFFFFFF" />  
			</s:fill>  
		</s:Rect>
		<s:Group id="leftResizeBar" width="5" height="{ScheduleFullView.TIMELINE_VIEW_HEIGHT}" left="0" bottom="0" mouseDown="leftResizeBarBeginDrag(event)" mouseOver="showResizeCursor(event)" mouseOut="hideResizeCursor(event)"/>
		<s:Group id="rightResizeBar" width="5" height="{ScheduleFullView.TIMELINE_VIEW_HEIGHT}" right="0" bottom="0" mouseDown="rightResizeBarBeginDrag(event)" mouseOver="showResizeCursor(event)" mouseOut="hideResizeCursor(event)"/>
	</s:Group>
	<s:filters>
		<s:GlowFilter id="glowFilter"
					  quality="3"
					  alpha="0.2"
					  color="0x000000"
					  blurX="5"
					  blurY="5"
					  strength="5"/>
	</s:filters>
</s:Group>
