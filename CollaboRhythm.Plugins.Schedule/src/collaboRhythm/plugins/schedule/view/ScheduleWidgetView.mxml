<?xml version="1.0" encoding="utf-8"?>
<!--
 ~ Copyright 2011 John Moore, Scott Gilroy
 ~
 ~ This file is part of CollaboRhythm.
 ~
 ~ CollaboRhythm is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 ~
 ~ CollaboRhythm is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 ~
 ~ You should have received a copy of the GNU General Public License along with CollaboRhythm.  If not, see <http://www.gnu.org/licenses/>.
 -->
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx"
		 clipAndEnableScrolling="true" xmlns:images="assets.images.*"
		 resize="resizeClock()"
		 creationComplete="startClock()"
		 >
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	<fx:Style>
		@namespace s "library://ns.adobe.com/flex/spark";
		@namespace mx "library://ns.adobe.com/flex/mx";
		
		.hour {
			color: #000000;
			font-size: 16;
			font-weight: bold;
		}
	</fx:Style>
	<fx:Script>
		<![CDATA[	
			import castle.flexbridge.reflection.Void;
			
			import collaboRhythm.workstation.apps.schedule.controller.ScheduleFullViewController;
			import collaboRhythm.workstation.apps.schedule.model.AdherenceGroup;
			import collaboRhythm.workstation.apps.schedule.model.Measurement;
			import collaboRhythm.workstation.apps.schedule.model.MoveData;
			import collaboRhythm.workstation.apps.schedule.model.ScheduleItemBase;
			import collaboRhythm.workstation.apps.schedule.model.ScheduleModel;
			
			import com.leebrimelow.drawing.Wedge;
			
			import mx.binding.utils.BindingUtils;
			import mx.collections.ArrayCollection;
			import mx.core.UIComponent;
			import mx.events.CollectionEvent;
			import mx.events.CollectionEventKind;
					
			[Bindable]
			private var _scheduleModel:ScheduleModel;
			private var _scheduleItemsCollection:ArrayCollection;
			private var _adherenceGroupsCollection:ArrayCollection;
			private var _widgetMedicationViews:Vector.<WidgetMedicationView>;
			private var _widgetAdherenceWindowViews:Vector.<WidgetAdherenceWindowView>;
			
			public function init(scheduleModel:ScheduleModel):void
			{
				_scheduleModel = scheduleModel;
			}
			
			// TODO
			public function initializeClock(scheduleModel:ScheduleModel):void
			{				
				_scheduleModel = scheduleModel;
				_scheduleItemsCollection = _scheduleModel.scheduleItemsCollection;
				_adherenceGroupsCollection = _scheduleModel.adherenceGroupsCollection;
				_widgetMedicationViews = new Vector.<WidgetMedicationView>;
				_widgetAdherenceWindowViews = new Vector.<WidgetAdherenceWindowView>;
				
				_scheduleItemsCollection.addEventListener(CollectionEvent.COLLECTION_CHANGE, scheduleItemsCollectionChangeHandler);
				_adherenceGroupsCollection.addEventListener(CollectionEvent.COLLECTION_CHANGE, adherenceGroupsCollectionChangeHandler);		
			}
			
			private function startClock():void
			{
				updateTime();
				
				// creates a Timer that fires an event once per 10 minutes
				var timer:Timer = new Timer(600000); 
				
				// designates the onTick() method to handle Timer events
				timer.addEventListener(TimerEvent.TIMER, onTick);
				
				// starts the clock ticking
				timer.start();
			}
			
			private function onTick(event:TimerEvent):void
			{
				updateTime();
			}
			
			private function updateTime():void
			{
				var currentTime:Date = _scheduleModel.now;
				var minutes:uint = currentTime.getMinutes();
				var hours:uint = currentTime.getHours();
				
				clockHand.rotation = (hours * 15) + (minutes * 0.25) - 135;;
			}
			
			public function get scheduleModel():ScheduleModel
			{
				return _scheduleModel;
			}
			
			public function set scheduleModel(value:ScheduleModel):void
			{
				_scheduleModel = value;
			}
			
			public function scheduleItemsCollectionChangeHandler(event:CollectionEvent):void
			{
				if (event.kind == CollectionEventKind.ADD)
				{
					for each (var scheduleItemAdded:ScheduleItemBase in event.items)
					{
						createScheduleItemView(scheduleItemAdded);
					}
				}
			}
			
			public function adherenceGroupsCollectionChangeHandler(event:CollectionEvent):void
			{
				if (event.kind == CollectionEventKind.ADD)
				{
					for each (var adherenceGroupAdded:AdherenceGroup in event.items)
					{
						createAdherenceWindowView(adherenceGroupAdded);
					}
				}
				else if (event.kind == CollectionEventKind.REMOVE)
				{
					for each (var adherenceGroupRemoved:AdherenceGroup in event.items)
					{
						destroyAdherenceWindowView(adherenceGroupRemoved);
					}
				}
			}

			public function createScheduleItemView(scheduleItem:ScheduleItemBase):void
			{
				var className:String = getQualifiedClassName(scheduleItem);
				if (className == "collaboRhythm.workstation.apps.medications.model::Medication")
				{
					var widgetMedicationView:WidgetMedicationView = new WidgetMedicationView();
					widgetMedicationView.medication = scheduleItem;
					widgetMedicationView.scheduleWidgetView = this;
					medicationsGroup.addElement(widgetMedicationView);
					_widgetMedicationViews.push(widgetMedicationView);
				}
				else if (className == "collaboRhythm.workstation.apps.schedule.model::Measurement")
				{
					var widgetMeasurementView:WidgetMeasurementView = new WidgetMeasurementView();
					widgetMeasurementView.measurement = Measurement(scheduleItem);
					widgetMeasurementView.scheduleWidgetView = this;
					medicationsGroup.addElement(widgetMeasurementView);
//					_widgetMedicationViews.push(widgetMeasurementView);
				}
			}
			
			public function createAdherenceWindowView(adherenceGroup:AdherenceGroup):void
			{				
				var widgetAdherenceWindowView:WidgetAdherenceWindowView = new WidgetAdherenceWindowView();
				widgetAdherenceWindowView.adherenceGroup = adherenceGroup;
				widgetAdherenceWindowView.scheduleWidgetView = this;
				adherenceGroupsGroup.addElement(widgetAdherenceWindowView);
				_widgetAdherenceWindowViews.push(widgetAdherenceWindowView);		
			}
			
			public function destroyAdherenceWindowView(adherenceGroup:AdherenceGroup):void
			{
				for each (var widgetAdherenceWindowView:WidgetAdherenceWindowView in _widgetAdherenceWindowViews)
				{
					if (widgetAdherenceWindowView.adherenceGroup == adherenceGroup)
					{
						var clockAdherenceWindowViewIndex:Number = _widgetAdherenceWindowViews.indexOf(widgetAdherenceWindowView);
						_widgetAdherenceWindowViews.splice(clockAdherenceWindowViewIndex, 1);
						adherenceGroupsGroup.removeElement(widgetAdherenceWindowView);
					}
				}
			}
			
			private function resizeClock():void
			{
				if (this.width < this.height)
				{
					medicationsGroup.width = medicationsGroup.height = this.width;
					clockBackground.width = clockBackground.height = this.width;
					clockForeground.width = clockForeground.height = this.width;
					clockHand.width = clockHand.height = this.width / 2;
				}
				else
				{
					medicationsGroup.width = medicationsGroup.height = this.height;
					clockBackground.width = clockBackground.height = this.height;
					clockForeground.width = clockForeground.height = this.height;
					clockHand.width = clockHand.height = this.height / 2;
				}
				clockHand.x = this.width / 2;
				clockHand.y = this.height / 2;
			}
		]]>
	</fx:Script>
	<images:clockBackground id="clockBackground" horizontalCenter="0" verticalCenter="0" />
	<s:Group id="adherenceGroupsGroup" top="10" left="10" bottom="10" right="10"/>
	<s:Group id="medicationsGroup" horizontalCenter="0" verticalCenter="0" />
	<images:clockHand id="clockHand" />
	<images:clockForeground id="clockForeground" horizontalCenter="0" verticalCenter="0" />
</s:Group>